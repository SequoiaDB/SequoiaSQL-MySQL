diff --git a/mariadb-v10.4.6/sp_head.cc b/mariadb-v10.4.6/sp_head.cc
index 48bd8ac..2626407 100644
--- a/mariadb-v10.4.6/sp_head.cc
+++ b/mariadb-v10.4.6/sp_head.cc
@@ -1377,7 +1377,49 @@ sp_head::execute(THD *thd, bool merge_da_on_success)
 
     /* Reset sp_rcontext::end_partial_result_set flag. */
     ctx->end_partial_result_set= FALSE;
-
+    
+    // retry current SQL statement
+    extern char *ha_inst_group_name;
+    if (err_status && thd->get_stmt_da()->is_error() && !thd->in_sub_stmt &&
+        ha_inst_group_name && 0 != strlen(ha_inst_group_name))
+    {
+      uint mysql_errno = thd->get_stmt_da()->sql_errno();
+      // notify HA set retry flag
+      mysql_audit_general(thd, 0, 0, "SetDMLRetryFlag");
+      if (mysql_errno && !thd->get_stmt_da()->is_set()) 
+      {
+        // 1. prepare-reexecution
+        if (thd->locked_tables_mode <= LTM_LOCK_TABLES)
+        {
+          user_var_events_alloc_saved= thd->user_var_events_alloc;
+          thd->user_var_events_alloc= thd->mem_root;
+        }
+        sql_digest_state *parent_digest= thd->m_digest;
+        thd->m_digest= NULL;
+        
+        // 2. reexecute
+        err_status = i->execute(thd, &ip);
+        
+        // 3. post-execution
+        thd->m_digest = parent_digest;
+        if (i->free_list)
+          cleanup_items(i->free_list);
+        if (thd->locked_tables_mode <= LTM_LOCK_TABLES)
+        {
+          reset_dynamic(&thd->user_var_events);
+          thd->user_var_events_alloc= user_var_events_alloc_saved;
+        }
+        thd->cleanup_after_query();
+        free_root(&execute_mem_root, MYF(0));
+        if (likely(!thd->is_fatal_error) && likely(!thd->killed_errno()) &&
+          ctx->handle_sql_condition(thd, &ip, i))
+        {
+          err_status= FALSE;
+        }
+        ctx->end_partial_result_set= FALSE;
+      }
+      mysql_audit_general(thd, 0, 0, "ResetDMLRetryFlag");
+    }
   } while (!err_status && likely(!thd->killed) &&
            likely(!thd->is_fatal_error) &&
            !thd->spcont->pause_state);
@@ -3282,6 +3324,7 @@ sp_lex_keeper::reset_lex_and_exec_core(THD *thd, uint *nextp,
     We should not save old value since it is saved/restored in
     sp_head::execute() when we are entering/leaving routine.
   */
+  LEX *lex_saved = thd->lex;
   thd->lex= m_lex;
 
   thd->set_query_id(next_query_id());
@@ -3326,6 +3369,22 @@ sp_lex_keeper::reset_lex_and_exec_core(THD *thd, uint *nextp,
 
   Json_writer_object trace_command(thd);
   Json_writer_array trace_command_steps(thd, "steps");
+
+  extern char *ha_inst_group_name;
+  Sroutine_hash_entry *sroutine_to_open = thd->lex->sroutines_list.first;
+  enum enum_sql_command sql_cmd = thd->lex->sql_command;
+  // for statement "set m:= 'select ...'" in procedure, mysql_execute_command
+  // will not be called, version check must be here
+  if (sroutine_to_open != NULL && !thd->in_sub_stmt &&
+     (SQLCOM_END == sql_cmd || SQLCOM_SET_OPTION == sql_cmd) &&
+      ha_inst_group_name && 0 != strlen(ha_inst_group_name))
+  {
+    enum enum_sql_command saved_cmd = thd->lex->sql_command;
+    thd->lex->sql_command = SQLCOM_SET_OPTION;
+    mysql_audit_general(thd, 0, 0, "PreCheckSQLObjects");
+    thd->lex->sql_command = saved_cmd;
+  }
+
   if (open_tables)
     res= check_dependencies_in_with_clauses(m_lex->with_clauses_list) ||
          instr->exec_open_and_lock_tables(thd, m_lex->query_tables);
@@ -3335,7 +3394,19 @@ sp_lex_keeper::reset_lex_and_exec_core(THD *thd, uint *nextp,
     res= instr->exec_core(thd, nextp);
     DBUG_PRINT("info",("exec_core returned: %d", res));
   }
-
+  
+  // notify HA store lex for current statement
+  extern char *ha_inst_group_name;
+  if (res && thd->is_error() &&
+     // not in any function
+     !thd->in_sub_stmt &&
+     // current statement does not include routines
+     (NULL == thd->lex->sroutines_list.first) &&
+      ha_inst_group_name && 0 != strlen(ha_inst_group_name))
+  {
+    mysql_audit_general(thd, 0, 0, "SaveInstrLex");
+  }
+  
   /*
     Call after unit->cleanup() to close open table
     key read.
@@ -3415,6 +3486,8 @@ sp_lex_keeper::reset_lex_and_exec_core(THD *thd, uint *nextp,
     cleanup_items() is called in sp_head::execute()
   */
   thd->lex->restore_set_statement_var();
+  /* Restore original lex. */
+  thd->lex= lex_saved;
   DBUG_RETURN(res || thd->is_error());
 }
 
diff --git a/mariadb-v10.4.6/sql_base.cc b/mariadb-v10.4.6/sql_base.cc
index 119c171..c6f0208 100644
--- a/mariadb-v10.4.6/sql_base.cc
+++ b/mariadb-v10.4.6/sql_base.cc
@@ -67,6 +67,7 @@
 #include "wsrep_trans_observer.h"
 #endif /* WITH_WSREP */
 
+#include "sql_audit.h"
 
 bool
 No_such_table_error_handler::handle_condition(THD *,
@@ -4290,6 +4291,16 @@ restart:
   while (*table_to_open  ||
          (thd->locked_tables_mode <= LTM_LOCK_TABLES && *sroutine_to_open))
   {
+    // check version after open tables, before lock tables
+    // for statement including routines
+    extern char *ha_inst_group_name;
+    if (thd->lex->sroutines_list.first != NULL &&
+        SQLCOM_CALL != thd->lex->sql_command &&
+        !thd->in_sub_stmt &&
+        ha_inst_group_name && 0 != strlen(ha_inst_group_name))
+    {
+      mysql_audit_general(thd, 0, 0, "PreCheckSQLObjects");
+    }
     /*
       For every table in the list of tables to open, try to find or open
       a table.
diff --git a/mariadb-v10.4.6/sql_class.cc b/mariadb-v10.4.6/sql_class.cc
index 94e2b51..35882ca 100644
--- a/mariadb-v10.4.6/sql_class.cc
+++ b/mariadb-v10.4.6/sql_class.cc
@@ -2945,6 +2945,20 @@ bool select_send::send_result_set_metadata(List<Item> &list, uint flags)
     return FALSE;
   }
 #endif /* WITH_WSREP */
+  
+  // do not send send_result_metadata once again for DML
+  extern char *ha_inst_group_name;
+  if (ha_inst_group_name && 0 != strlen(ha_inst_group_name)) 
+  {
+    extern pthread_key_t ha_sql_stmt_info_key;
+    bool *is_ha_result_set_started = (bool*)pthread_getspecific(ha_sql_stmt_info_key);
+    if (is_ha_result_set_started && (*is_ha_result_set_started)) 
+    {
+      // *is_ha_result_set_started = false;
+      return false;
+    }
+  }
+  
   if (!(res= thd->protocol->send_result_set_metadata(&list, flags)))
     is_result_set_started= 1;
   return res;
diff --git a/mariadb-v10.4.6/sql_parse.cc b/mariadb-v10.4.6/sql_parse.cc
index e49dbe9..a13e97b 100644
--- a/mariadb-v10.4.6/sql_parse.cc
+++ b/mariadb-v10.4.6/sql_parse.cc
@@ -1511,6 +1511,61 @@ uint maria_multi_check(THD *thd, char *packet, size_t packet_length)
 }
 
 
+void reset_execution_ctx(THD *thd, char *beginning_of_next_stmt, 
+                         ulong length, enum enum_server_command command) 
+{
+  thd->get_stmt_da()->set_skip_flush();
+#ifdef WITH_ARIA_STORAGE_ENGINE
+  ha_maria::implicit_commit(thd, FALSE);
+#endif
+
+  /* Finalize server status flags after executing a statement. */
+  thd->update_server_status();
+  query_cache_end_of_result(thd);
+
+  log_slow_statement(thd);
+  DBUG_ASSERT(!thd->apc_target.is_enabled());
+
+  /* PSI end */
+  MYSQL_END_STATEMENT(thd->m_statement_psi, thd->get_stmt_da());
+  thd->m_statement_psi= NULL;
+  thd->m_digest= NULL;
+
+  /* DTRACE end */
+  if (MYSQL_QUERY_DONE_ENABLED())
+  {
+    MYSQL_QUERY_DONE(thd->is_error());
+  }
+
+#if defined(ENABLED_PROFILING)
+  thd->profiling.finish_current_query();
+  thd->profiling.start_new_query("continuing");
+  thd->profiling.set_query_source(beginning_of_next_stmt, length);
+#endif
+
+          /* DTRACE begin */
+  MYSQL_QUERY_START(beginning_of_next_stmt, thd->thread_id,
+                    thd->get_db(),
+                    &thd->security_ctx->priv_user[0],
+                    (char *) thd->security_ctx->host_or_ip);
+
+  /* PSI begin */
+  thd->m_digest= & thd->m_digest_state;
+  thd->m_statement_psi= MYSQL_START_STATEMENT(&thd->m_statement_state,
+                                              com_statement_info[command].m_key,
+                                              thd->db.str, thd->db.length,
+                                              thd->charset());
+  THD_STAGE_INFO(thd, stage_init);
+  MYSQL_SET_STATEMENT_TEXT(thd->m_statement_psi, beginning_of_next_stmt,
+                           length);
+  thd->set_query_and_id(beginning_of_next_stmt, length,
+                        thd->charset(), next_query_id());
+  statistic_increment(thd->status_var.questions, &LOCK_status);
+
+  if (!WSREP(thd))
+    thd->set_time();
+}
+
 /**
   Perform one connection-level (COM_XXXX) command.
 
@@ -1827,7 +1882,37 @@ bool dispatch_command(enum enum_server_command command, THD *thd,
 #endif /* WITH_WSREP */
       mysql_parse(thd, thd->query(), thd->query_length(), &parser_state,
                   is_com_multi, is_next_command);
-
+    
+    // sequoiadb-sql DML retry 
+    {
+      extern char *ha_inst_group_name;
+      if (thd->get_stmt_da()->is_error() && ha_inst_group_name && 
+        0 != strlen(ha_inst_group_name) &&
+        // does not include any routines
+        0 == thd->lex->sroutines_list.elements) {
+        uint mysql_errno = thd->get_stmt_da()->sql_errno();
+        // notify HA set retry flag
+        mysql_audit_general(thd, 0, 0, "SetDMLRetryFlag");
+        if (mysql_errno && !thd->get_stmt_da()->is_set())
+        {
+          char *beginning_of_next_stmt = (char*)thd->query();
+          ulong length= (ulong)(thd->query_length());
+          reset_execution_ctx(thd, beginning_of_next_stmt, length, command);
+          parser_state.reset(beginning_of_next_stmt, length);
+          
+          mysql_parse(thd, beginning_of_next_stmt, length, &parser_state,
+                      is_com_multi, is_next_command);
+        }
+        // reset retry flag
+        mysql_audit_general(thd, 0, 0, "ResetDMLRetryFlag");
+      }
+      // clear checked objects cache
+      if (ha_inst_group_name && 0 != strlen(ha_inst_group_name))
+      {
+        mysql_audit_general(thd, 0, 0, "ResetCheckedObjects");
+      }
+    }
+                  
     while (!thd->killed && (parser_state.m_lip.found_semicolon != NULL) &&
            ! thd->is_error())
     {
@@ -1932,7 +2017,35 @@ bool dispatch_command(enum enum_server_command command, THD *thd,
 #endif /* WITH_WSREP */
       mysql_parse(thd, beginning_of_next_stmt, length, &parser_state,
                   is_com_multi, is_next_command);
-
+      
+      // sequoiadb-sql DML retry 
+      {
+        extern char *ha_inst_group_name;
+        if (thd->get_stmt_da()->is_error() && ha_inst_group_name && 
+          0 != strlen(ha_inst_group_name) &&
+          // does not include any routines
+          0 == thd->lex->sroutines_list.elements)
+        {
+          uint mysql_errno = thd->get_stmt_da()->sql_errno();
+          // notify HA set retry flag
+          mysql_audit_general(thd, 0, 0, "SetDMLRetryFlag");
+          if (mysql_errno && !thd->get_stmt_da()->is_set()) 
+          {
+            reset_execution_ctx(thd, beginning_of_next_stmt, length, command);
+            parser_state.reset(beginning_of_next_stmt, length);
+            
+            mysql_parse(thd, beginning_of_next_stmt, length, &parser_state,
+                        is_com_multi, is_next_command);
+          }
+          // reset retry flag
+          mysql_audit_general(thd, 0, 0, "ResetDMLRetryFlag");
+        }
+        // clear checked objects cache
+        if (ha_inst_group_name && 0 != strlen(ha_inst_group_name)) 
+        {
+          mysql_audit_general(thd, 0, 0, "ResetCheckedObjects");
+        }
+      }
     }
 
     DBUG_PRINT("info",("query ready"));
@@ -3715,6 +3828,16 @@ mysql_execute_command(THD *thd)
   if (lex->sql_command != SQLCOM_SET_OPTION)
     DEBUG_SYNC(thd,"before_execute_sql_command");
 #endif
+  
+  static const int MYSQL_AUDIT_QUERY_BEGIN = 4;
+  static const int MYSQL_AUDIT_QUERY_END = 5;
+  mysql_audit_general(thd, MYSQL_AUDIT_QUERY_BEGIN,
+                      thd->get_stmt_da()->is_error() ?
+                      thd->get_stmt_da()->sql_errno() : 0,
+                      command_name[COM_QUERY].str);
+  if (thd->check_killed()) {
+  	goto error;
+  }
 
   /*
     Check if we are in a read-only transaction and we're trying to
@@ -6100,6 +6223,11 @@ finish:
   thd->reset_query_timer();
   DBUG_ASSERT(!thd->in_active_multi_stmt_transaction() ||
                thd->in_multi_stmt_transaction_mode());
+  
+  mysql_audit_general(thd, MYSQL_AUDIT_QUERY_END,
+                      thd->get_stmt_da()->is_error() ?
+                      thd->get_stmt_da()->sql_errno() : 0,
+                      command_name[COM_QUERY].str);
 
   lex->unit.cleanup();
 
