From 79720afeb0eda9159701ccad665c1a73c0ba07c0 Mon Sep 17 00:00:00 2001
From: yuweixing <yuweixing@sequoiadb.com>
Date: Mon, 28 Dec 2020 14:45:13 +0800
Subject: [PATCH] =?UTF-8?q?SEQUOIASQLMAINSTREAM-850=20=E6=94=AF=E6=8C=81?=
 =?UTF-8?q?=E4=B8=8B=E5=8E=8B=E5=86=85=E7=BD=AE=20SQL=20=E5=88=B0=20SPARK.?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

---
 sql/sql_class.h    | 17 +++++++++
 sql/sql_parse.cc   | 85 +++++++++++++++++++++++++++++++++++++++++++-
 sql/sql_prepare.cc | 87 +++++++++++++++++++++++++++++++++++++++++++++-
 sql/sql_prepare.h  |  8 +++++
 sql/sys_vars.cc    |  9 +++++
 sql/sys_vars.h     |  2 ++
 6 files changed, 206 insertions(+), 2 deletions(-)

diff --git a/sql/sql_class.h b/sql/sql_class.h
index ae44dae3..e8923985 100644
--- a/sql/sql_class.h
+++ b/sql/sql_class.h
@@ -580,6 +580,7 @@ typedef struct system_variables
     'COLUMN_TYPE' field.
   */
   my_bool show_old_temporals;
+  my_bool sdb_sql_pushdown;
 } SV;
 
 
@@ -4403,6 +4404,10 @@ public:
   void set_query(const LEX_CSTRING& query_arg);
   void reset_query() {
     set_query(LEX_CSTRING());
+    DBUG_ASSERT(this == current_thd);
+    mysql_mutex_lock(&LOCK_thd_query);
+    sdb_sql_push_down_query_string = LEX_CSTRING();
+    mysql_mutex_unlock(&LOCK_thd_query);
   }
 
   /**
@@ -4761,6 +4766,18 @@ private:
     aggregates THD.
   */
   bool is_a_srv_session_thd;
+
+public:
+  /* String hold to push down to sequoiadb coord to exec. */
+  LEX_CSTRING sdb_sql_push_down_query_string;
+  enum sdb_sql_push_down_exec_steps {
+    NON_PUSH_DOWN = 0,
+    PREPARE_STEP = 1,
+    EXEC_STEP = 2,
+  };
+  /* Flag of the real push down join exec finised. All the other result need to
+     be ignored but the real result of join exec. */
+  sdb_sql_push_down_exec_steps sdb_sql_exec_step;
 };
 
 /**
diff --git a/sql/sql_parse.cc b/sql/sql_parse.cc
index 39b266c8..90079e78 100644
--- a/sql/sql_parse.cc
+++ b/sql/sql_parse.cc
@@ -119,6 +119,7 @@
 #include <algorithm>
 using std::max;
 
+#include "sys_vars.h"
 /**
   @defgroup Runtime_Environment Runtime Environment
   @{
@@ -1479,11 +1480,77 @@ bool dispatch_command(THD *thd, const COM_DATA *com_data,
                                      thd->query().length);
 
     DBUG_PRINT("query",("%-.4096s", thd->query().str));
+    thd->sdb_sql_exec_step = thd->NON_PUSH_DOWN;
 
 #if defined(ENABLED_PROFILING)
     thd->profiling.set_query_source(thd->query().str, thd->query().length);
 #endif
 
+    char *push_down_sql = NULL;
+    char *concat_join_push_down_sql = NULL;
+    bool add_multi_query_flag = false;
+    push_type type = NO_PUSH;
+
+    if(thd->variables.sdb_sql_pushdown) {
+      const int LEN_OF_CONCAT_STR = 400;
+      int len_of_concat = thd->query().length + LEN_OF_CONCAT_STR + 1;
+
+      type = sql_pushdown(thd, &push_down_sql);
+      if (NO_PUSH == type) {
+        goto original_step;
+      }
+
+      concat_join_push_down_sql = (char*)thd->alloc(len_of_concat);
+      if (NULL == concat_join_push_down_sql)
+      {
+        type = NO_PUSH;
+        goto original_step;
+      }
+
+      concat_join_push_down_sql[0] = '\0';
+      if (PUSH_TO_SPK == type) {
+        snprintf(concat_join_push_down_sql, len_of_concat,
+          "drop table if exists `I#T#TEMP#PHJ`;"
+          "set session `spark_execute_only_in_mysql` = on;"
+          "set session `sequoiadb_execute_only_in_mysql` = on;"
+          "create temporary table if not exists `I#T#TEMP#PHJ` engine = spark "
+          "as %s;%s",push_down_sql,
+          "set session `spark_execute_only_in_mysql` = off;"
+          "set session `sequoiadb_execute_only_in_mysql` = off;"
+          "select * from `I#T#TEMP#PHJ`;"
+          "drop table if exists `I#T#TEMP#PHJ`;");
+      }
+
+      if (PUSH_TO_SDB == type) {
+        snprintf(concat_join_push_down_sql, len_of_concat,
+        "drop table if exists `I#T#TEMP#PHJ`;"
+        "set session `sequoiadb_execute_only_in_mysql` = on;"
+        "create temporary table if not exists `I#T#TEMP#PHJ` engine = sequoiadb "
+        "as %s;%s",push_down_sql,
+        "set session `sequoiadb_execute_only_in_mysql` = off;"
+        "select * from `I#T#TEMP#PHJ`;"
+        "drop table if exists `I#T#TEMP#PHJ`;");
+      }
+
+      LEX_CSTRING concat_lex_str =
+         {concat_join_push_down_sql, strlen(concat_join_push_down_sql)};
+      LEX_CSTRING join_query_lex_str =
+         {push_down_sql, strlen(push_down_sql)};
+
+      mysql_mutex_lock(&thd->LOCK_thd_query);
+      thd->sdb_sql_push_down_query_string = join_query_lex_str;
+      mysql_mutex_unlock(&thd->LOCK_thd_query);
+      thd->set_query(concat_lex_str);
+      packet_end= thd->query().str + thd->query().length;
+      thd->sdb_sql_exec_step = thd->PREPARE_STEP;
+      if (!thd->get_protocol_classic()->has_client_capability(CLIENT_MULTI_STATEMENTS)) {
+        thd->get_protocol_classic()->add_client_capability(
+          CLIENT_MULTI_STATEMENTS);
+        add_multi_query_flag = true;
+      }
+    }
+
+original_step:
     Parser_state parser_state;
     if (parser_state.init(thd, thd->query().str, thd->query().length))
       break;
@@ -1500,7 +1567,22 @@ bool dispatch_command(THD *thd, const COM_DATA *com_data,
 
       /* Finalize server status flags after executing a statement. */
       thd->update_server_status();
-      thd->send_statement_status();
+
+      if (thd->variables.sdb_sql_pushdown) {
+        /* If push down hash join sql to sdb, then only send the result of 
+           join sql exec.*/
+        if(thd->PREPARE_STEP == thd->sdb_sql_exec_step) {
+        } else {
+          thd->send_statement_status();
+          if (add_multi_query_flag) {
+            thd->get_protocol_classic()->remove_client_capability(
+            CLIENT_MULTI_STATEMENTS);
+          }
+        }
+      } else {
+        thd->send_statement_status();
+      }
+
       query_cache.end_of_result(thd);
 
 #ifndef EMBEDDED_LIBRARY
@@ -1931,6 +2013,7 @@ done:
   THD_STAGE_INFO(thd, stage_cleaning_up);
 
   thd->reset_query();
+  thd->sdb_sql_exec_step = thd->NON_PUSH_DOWN;
   thd->set_command(COM_SLEEP);
   thd->proc_info= 0;
   thd->lex->sql_command= SQLCOM_END;
diff --git a/sql/sql_prepare.cc b/sql/sql_prepare.cc
index bdae6ec4..2d94fcfe 100644
--- a/sql/sql_prepare.cc
+++ b/sql/sql_prepare.cc
@@ -130,6 +130,85 @@ When one supplies long data for a placeholder:
 using std::max;
 using std::min;
 
+push_type sql_pushdown(THD *thd, char **push_down_sql) {
+  char *upperred_origin = NULL;
+  int offset_to_keyword = -1;
+  push_type type = NO_PUSH;
+
+  if(thd->variables.sdb_sql_pushdown) {
+    const char* SPK_STR = "SPARK";
+    const char* SDB = "SDB";
+    int pushdown_key_len = 0;
+    int pushdown_len = 0;
+    uint original_sql_len = thd->query().length;
+    const char *original_sql = thd->query().str;
+
+    upperred_origin = (char*)thd->alloc(original_sql_len + 1);
+    if (NULL == upperred_origin)
+    {
+      type = NO_PUSH;
+      goto error;
+    }
+
+    upperred_origin[0] = '\0';
+    snprintf(upperred_origin, original_sql_len + 1, "%s", thd->query().str);
+    for (uint i = 0; i < original_sql_len + 1; i++) {
+      upperred_origin[i] = toupper(upperred_origin[i]);
+    }
+
+    String pushdown_key_word("/*+SQL_PUSHDOWN=", &my_charset_utf8mb4_bin);
+    String upperred_string(upperred_origin, &my_charset_utf8mb4_bin);
+    
+    offset_to_keyword = upperred_string.strstr(pushdown_key_word);
+    /*-1 or offset, -1 not found*/
+    if (-1 == offset_to_keyword) {
+      type = NO_PUSH;
+      goto error;
+    }
+    
+    pushdown_key_len += pushdown_key_word.length();
+    /*push down to Spark*/
+    if(0 == strncmp(&upperred_origin[offset_to_keyword + pushdown_key_len],
+                    SPK_STR, strlen(SPK_STR))) {
+      pushdown_key_len+=strlen(SPK_STR);
+      type = PUSH_TO_SPK;
+    /*pushdown to SDB*/
+    } else if(0 == strncmp(&upperred_origin[offset_to_keyword + pushdown_key_len],
+                           SDB, strlen(SDB))) {
+      pushdown_key_len+=strlen(SDB);
+      type = PUSH_TO_SDB;
+    }
+
+    pushdown_key_len += strlen("*/");
+
+    if (!push_down_sql) {
+      goto done;
+    }
+
+    *push_down_sql = (char*)thd->alloc(original_sql_len + 1);
+    if (NULL == *push_down_sql)
+    {
+      type = NO_PUSH;
+      goto error;
+    }
+
+    (*push_down_sql)[0] = '\0';
+
+    //*Remove /*+SQL_PUSHDOWN=SDB*/ from original sql.
+    //*/*+SQL_PUSHDOWN=SDB*/select count, select /*+SQL_PUSHDOWN=SDB*/ count
+    pushdown_len = snprintf(*push_down_sql, offset_to_keyword + 1, "%s",
+                           original_sql);
+    pushdown_len += snprintf(&(*push_down_sql)[offset_to_keyword],
+              original_sql_len - offset_to_keyword, "%s",
+              &original_sql[offset_to_keyword + pushdown_key_len]);
+
+  }
+done:
+  return type;
+error:
+  goto done;
+}
+
 /****************************************************************************/
 
 /**
@@ -3302,8 +3381,14 @@ bool Prepared_statement::prepare(const char *query_str, size_t query_length)
   invoke_pre_parse_rewrite_plugins(thd);
   thd->m_parser_state = NULL;
 
-  error= thd->is_error();
+  /*Not support prepare statement for sql pushdown to sdb or spark.*/
+  push_type type = NO_PUSH;
+  type = sql_pushdown(thd, NULL);
+  if (NO_PUSH != type) {
+    my_error(ER_UNSUPPORTED_PS, MYF(0));
+  }
 
+  error= thd->is_error();
   if (!error)
   {
     error = parse_sql(thd, &parser_state, NULL) ||
diff --git a/sql/sql_prepare.h b/sql/sql_prepare.h
index d82b0e6b..1bd0f4c8 100644
--- a/sql/sql_prepare.h
+++ b/sql/sql_prepare.h
@@ -496,4 +496,12 @@ private:
 #endif
 };
 
+enum push_type {
+  NO_PUSH = 0,
+  PUSH_TO_SDB = 1,//push down to sequoiadb
+  PUSH_TO_SPK = 2,//push down to spark
+};
+
+push_type sql_pushdown(THD *thd, char **push_down_sql);
+
 #endif // SQL_PREPARE_H
diff --git a/sql/sys_vars.cc b/sql/sys_vars.cc
index f7d0e442..93a19602 100644
--- a/sql/sys_vars.cc
+++ b/sql/sys_vars.cc
@@ -5988,3 +5988,12 @@ static Sys_var_mybool Sys_keyring_operations(
        NOT_IN_BINLOG,
        ON_CHECK(check_keyring_access),
        ON_UPDATE(0));
+
+const bool sdb_sql_pushdown = false;
+
+static Sys_var_mybool Sys_sequoiadb_push_down_join(
+       "sequoiadb_sql_push_down",
+       "Whether push down join query or not.",
+       SESSION_VAR(sdb_sql_pushdown), CMD_LINE(OPT_ARG),
+       DEFAULT(FALSE));
+
diff --git a/sql/sys_vars.h b/sql/sys_vars.h
index 09022eca..204dc3d6 100644
--- a/sql/sys_vars.h
+++ b/sql/sys_vars.h
@@ -3017,5 +3017,7 @@ err:
   }
 };
 
+extern const bool sdb_sql_pushdown;
+
 #endif /* SYS_VARS_H_INCLUDED */
 
-- 
2.28.0.windows.1

