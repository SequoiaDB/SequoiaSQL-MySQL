diff --git a/sql/sql_class.h b/sql/sql_class.h
index dd9cfbbd..43b5c2ca 100644
--- a/sql/sql_class.h
+++ b/sql/sql_class.h
@@ -769,6 +769,7 @@ typedef struct system_variables
 
   vers_asof_timestamp_t vers_asof_timestamp;
   ulong vers_alter_history;
+  my_bool sdb_sql_pushdown;
 } SV;
 
 /**
@@ -4492,8 +4493,13 @@ public:
 
     PSI_CALL_set_thread_info(query(), query_length());
   }
-  void reset_query()               /* Mutex protected */
-  { set_query(CSET_STRING()); }
+  void reset_query() {               /* Mutex protected */
+    set_query(CSET_STRING());
+    DBUG_ASSERT(this == current_thd);
+    mysql_mutex_lock(&LOCK_thd_data);
+    sdb_sql_push_down_query_string = LEX_CSTRING();
+    mysql_mutex_unlock(&LOCK_thd_data);
+  }
   void set_query_and_id(char *query_arg, uint32 query_length_arg,
                         CHARSET_INFO *cs, query_id_t new_query_id);
   void set_query_id(query_id_t new_query_id)
@@ -4982,6 +4988,17 @@ public:
   Item *sp_fix_func_item(Item **it_addr);
   Item *sp_prepare_func_item(Item **it_addr, uint cols= 1);
   bool sp_eval_expr(Field *result_field, Item **expr_item_ptr);
+public:
+  /* String hold to push down to sequoiadb coord to exec. */
+  LEX_CSTRING sdb_sql_push_down_query_string;
+  enum sdb_sql_push_down_exec_steps {
+    NON_PUSH_DOWN = 0,
+    PREPARE_STEP = 1,
+    EXEC_STEP = 2,
+  };
+  /* Flag of the real push down join exec finised. All the other result need to
+     be ignored but the real result of join exec. */
+  sdb_sql_push_down_exec_steps sdb_sql_exec_step;
 };
 
 /** A short cut for thd->get_stmt_da()->set_ok_status(). */
diff --git a/sql/sql_parse.cc b/sql/sql_parse.cc
index e49dbe9f..e64cc07b 100644
--- a/sql/sql_parse.cc
+++ b/sql/sql_parse.cc
@@ -104,6 +104,8 @@
 
 #include "my_json_writer.h" 
 
+extern const bool sdb_sql_pushdown;
+
 #define FLAGSTR(V,F) ((V)&(F)?#F" ":"")
 
 #ifdef WITH_ARIA_STORAGE_ENGINE
@@ -1803,6 +1805,80 @@ bool dispatch_command(enum enum_server_command command, THD *thd,
     MYSQL_SET_STATEMENT_TEXT(thd->m_statement_psi, thd->query(),
                              thd->query_length());
 
+    thd->sdb_sql_exec_step = thd->NON_PUSH_DOWN;
+    char *push_down_sql = NULL;
+    char *concat_join_push_down_sql = NULL;
+    bool add_multi_query_flag = false;
+    push_type type = NO_PUSH;
+
+    if(thd->variables.sdb_sql_pushdown) {
+      const int LEN_OF_CONCAT_STR = 700;
+      int len_of_concat = thd->query_length() + LEN_OF_CONCAT_STR + 1;
+
+      type = sql_pushdown(thd, &push_down_sql);
+      if (NO_PUSH == type) {
+        goto original_step;
+      }
+
+      concat_join_push_down_sql = (char*)thd->alloc(len_of_concat);
+      if (NULL == concat_join_push_down_sql)
+      {
+        type = NO_PUSH;
+        goto original_step;
+      }
+
+      concat_join_push_down_sql[0] = '\0';
+      if (PUSH_TO_SPK == type) {
+        snprintf(concat_join_push_down_sql, len_of_concat,
+          "set @`sdb#pd#exec#in#only#mysql` = @@sequoiadb_execute_only_in_mysql;"
+          "set @`spk#pd#exec#in#only#mysql` = @@spark_execute_only_in_mysql;"
+          "drop table if exists `I#T#TEMP#PHJ`;"
+          "set session `spark_execute_only_in_mysql` = on;"
+          "set session `sequoiadb_execute_only_in_mysql` = on;"
+          "create temporary table if not exists `I#T#TEMP#PHJ` engine = spark "
+          "as %s;%s",push_down_sql,
+          "set session `spark_execute_only_in_mysql` = off;"
+          "set session `sequoiadb_execute_only_in_mysql` = off;"
+          "select * from `I#T#TEMP#PHJ`;"
+          "drop table if exists `I#T#TEMP#PHJ`;"
+          "set @@sequoiadb_execute_only_in_mysql = @`sdb#pd#exec#in#only#mysql`;"
+          "set @@spark_execute_only_in_mysql = @`spk#pd#exec#in#only#mysql`;");
+      }
+
+      if (PUSH_TO_SDB == type) {
+        snprintf(concat_join_push_down_sql, len_of_concat,
+          "set @`sdb#pd#exec#in#only#mysql` = @@sequoiadb_execute_only_in_mysql;"
+          "set @`spk#pd#exec#in#only#mysql` = @@spark_execute_only_in_mysql;"
+          "drop table if exists `I#T#TEMP#PHJ`;"
+          "set session `sequoiadb_execute_only_in_mysql` = on;"
+          "create temporary table if not exists `I#T#TEMP#PHJ` engine = sequoiadb "
+          "as %s;%s",push_down_sql,
+          "set session `sequoiadb_execute_only_in_mysql` = off;"
+          "select * from `I#T#TEMP#PHJ`;"
+          "drop table if exists `I#T#TEMP#PHJ`;"
+          "set @@sequoiadb_execute_only_in_mysql = @`sdb#pd#exec#in#only#mysql`;"
+          "set @@spark_execute_only_in_mysql = @`spk#pd#exec#in#only#mysql`;");
+      }
+
+      CSET_STRING concat_lex_str(concat_join_push_down_sql,
+                                 strlen(concat_join_push_down_sql),
+                                 &my_charset_utf8mb4_bin);
+      LEX_CSTRING join_query_lex_str =
+         {push_down_sql, strlen(push_down_sql)};
+
+      mysql_mutex_lock(&thd->LOCK_thd_data);
+      thd->sdb_sql_push_down_query_string = join_query_lex_str;
+      mysql_mutex_unlock(&thd->LOCK_thd_data);
+      thd->set_query(concat_lex_str);
+      packet_end= thd->query() + thd->query_length();
+      thd->sdb_sql_exec_step = thd->PREPARE_STEP;
+      if (!(thd->client_capabilities & CLIENT_MULTI_STATEMENTS)) {
+        thd->client_capabilities|= CLIENT_MULTI_STATEMENTS;
+        add_multi_query_flag = true;
+      }
+    }
+
+original_step:
     Parser_state parser_state;
     if (unlikely(parser_state.init(thd, thd->query(), thd->query_length())))
       break;
@@ -1843,7 +1919,21 @@ bool dispatch_command(enum enum_server_command command, THD *thd,
 
       /* Finalize server status flags after executing a statement. */
       thd->update_server_status();
-      thd->protocol->end_statement();
+      if (thd->variables.sdb_sql_pushdown) {
+        /* If push down hash join sql to sdb, then only send the result of 
+           join sql exec.*/
+        if(thd->PREPARE_STEP == thd->sdb_sql_exec_step) {
+        } else if(thd->EXEC_STEP == thd->sdb_sql_exec_step) {
+          thd->protocol->end_statement();
+          if (add_multi_query_flag) {
+            thd->client_capabilities&= ~CLIENT_MULTI_STATEMENTS;
+          }
+          /*Only send the execute result to client*/
+          thd->sdb_sql_exec_step = thd->NON_PUSH_DOWN;
+        }
+      } else {
+        thd->protocol->end_statement();
+      }
       query_cache_end_of_result(thd);
 
       mysql_audit_general(thd, MYSQL_AUDIT_GENERAL_STATUS,
diff --git a/sql/sql_prepare.cc b/sql/sql_prepare.cc
index 8088b692..d481dd33 100644
--- a/sql/sql_prepare.cc
+++ b/sql/sql_prepare.cc
@@ -124,6 +124,87 @@ When one supplies long data for a placeholder:
 #include "transaction.h"                        // trans_rollback_implicit
 #include "wsrep_mysqld.h"
 
+extern const bool sdb_sql_pushdown;
+
+push_type sql_pushdown(THD *thd, char **push_down_sql) {
+  char *upperred_origin = NULL;
+  int offset_to_keyword = -1;
+  push_type type = NO_PUSH;
+
+  if(thd->variables.sdb_sql_pushdown) {
+    const char* SPK_STR = "SPARK";
+    const char* SDB = "SDB";
+    int pushdown_key_len = 0;
+    int pushdown_len = 0;
+    uint original_sql_len = thd->query_length();
+    const char *original_sql = thd->query();
+
+    upperred_origin = (char*)thd->alloc(original_sql_len + 1);
+    if (NULL == upperred_origin)
+    {
+      type = NO_PUSH;
+      goto error;
+    }
+
+    upperred_origin[0] = '\0';
+    snprintf(upperred_origin, original_sql_len + 1, "%s", thd->query());
+    for (uint i = 0; i < original_sql_len + 1; i++) {
+      upperred_origin[i] = toupper(upperred_origin[i]);
+    }
+
+    String pushdown_key_word("/*+SQL_PUSHDOWN=", &my_charset_utf8mb4_bin);
+    String upperred_string(upperred_origin, &my_charset_utf8mb4_bin);
+    
+    offset_to_keyword = upperred_string.strstr(pushdown_key_word);
+    /*-1 or offset, -1 not found*/
+    if (-1 == offset_to_keyword) {
+      type = NO_PUSH;
+      goto error;
+    }
+    
+    pushdown_key_len += pushdown_key_word.length();
+    /*push down to Spark*/
+    if(0 == strncmp(&upperred_origin[offset_to_keyword + pushdown_key_len],
+                    SPK_STR, strlen(SPK_STR))) {
+      pushdown_key_len+=strlen(SPK_STR);
+      type = PUSH_TO_SPK;
+    /*pushdown to SDB*/
+    } else if(0 == strncmp(&upperred_origin[offset_to_keyword + pushdown_key_len],
+                           SDB, strlen(SDB))) {
+      pushdown_key_len+=strlen(SDB);
+      type = PUSH_TO_SDB;
+    }
+
+    pushdown_key_len += strlen("*/");
+
+    if (!push_down_sql) {
+      goto done;
+    }
+
+    *push_down_sql = (char*)thd->alloc(original_sql_len + 1);
+    if (NULL == *push_down_sql)
+    {
+      type = NO_PUSH;
+      goto error;
+    }
+
+    (*push_down_sql)[0] = '\0';
+
+    //*Remove /*+SQL_PUSHDOWN=SDB*/ from original sql.
+    //*/*+SQL_PUSHDOWN=SDB*/select count, select /*+SQL_PUSHDOWN=SDB*/ count
+    pushdown_len = snprintf(*push_down_sql, offset_to_keyword + 1, "%s",
+                           original_sql);
+    pushdown_len += snprintf(&(*push_down_sql)[offset_to_keyword],
+              original_sql_len - offset_to_keyword, "%s",
+              &original_sql[offset_to_keyword + pushdown_key_len]);
+
+  }
+done:
+  return type;
+error:
+  goto done;
+}
+
 /**
   A result class used to send cursor rows using the binary protocol.
 */
@@ -4010,6 +4091,13 @@ bool Prepared_statement::prepare(const char *packet, uint packet_len)
   lex_start(thd);
   lex->context_analysis_only|= CONTEXT_ANALYSIS_ONLY_PREPARE;
 
+  /*Not support prepare statement for sql pushdown to sdb or spark.*/
+  push_type type = NO_PUSH;
+  type = sql_pushdown(thd, NULL);
+  if (NO_PUSH != type) {
+    my_error(ER_UNSUPPORTED_PS, MYF(0));
+  }
+
   error= (parse_sql(thd, & parser_state, NULL) ||
           thd->is_error() ||
           init_param_array(this));
diff --git a/sql/sql_prepare.h b/sql/sql_prepare.h
index f1c4e5e4..4e601af2 100644
--- a/sql/sql_prepare.h
+++ b/sql/sql_prepare.h
@@ -352,4 +352,12 @@ private:
   size_t m_column_count; /* TODO: change to point to metadata */
 };
 
+enum push_type {
+  NO_PUSH = 0,
+  PUSH_TO_SDB = 1,//push down to sequoiadb
+  PUSH_TO_SPK = 2,//push down to spark
+};
+
+push_type sql_pushdown(THD *thd, char **push_down_sql);
+
 #endif // SQL_PREPARE_H
diff --git a/sql/sys_vars.cc b/sql/sys_vars.cc
index f2a60008..d455b70e 100644
--- a/sql/sys_vars.cc
+++ b/sql/sys_vars.cc
@@ -6359,3 +6359,12 @@ static Sys_var_ulonglong Sys_max_rowid_filter_size(
        SESSION_VAR(max_rowid_filter_size), CMD_LINE(REQUIRED_ARG),
        VALID_RANGE(1024, (ulonglong)~(intptr)0), DEFAULT(128*1024),
        BLOCK_SIZE(1));
+
+const bool sdb_sql_pushdown = false;
+
+static Sys_var_mybool Sys_sequoiadb_push_down_join(
+      "sequoiadb_sql_push_down",
+      "Whether push down join query or not.",
+      SESSION_VAR(sdb_sql_pushdown), CMD_LINE(OPT_ARG),
+      DEFAULT(FALSE));
+
diff --git a/sql/sys_vars.ic b/sql/sys_vars.ic
index aefae6d5..ae92e1c6 100644
--- a/sql/sys_vars.ic
+++ b/sql/sys_vars.ic
@@ -2707,3 +2707,5 @@ public:
   virtual uchar *global_value_ptr(THD *thd, const LEX_CSTRING *base)
   { return value_ptr(thd, global_var(vers_asof_timestamp_t)); }
 };
+
+
