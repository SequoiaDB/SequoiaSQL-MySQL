diff --git a/mysql-v5.7.25/sp_head.cc b/mysql-v5.7.25/sp_head.cc
index c824499..c5f91b4 100644
--- a/mysql-v5.7.25/sp_head.cc
+++ b/mysql-v5.7.25/sp_head.cc
@@ -39,6 +39,7 @@
 #include <my_user.h>           // parse_user
 #include "mysql/psi/mysql_statement.h"
 #include "mysql/psi/mysql_sp.h"
+#include "sql_audit.h"
 
 #ifdef HAVE_PSI_INTERFACE
 void init_sp_psi_keys()
@@ -826,6 +827,49 @@ bool sp_head::execute(THD *thd, bool merge_da_on_success)
     /* Reset sp_rcontext::end_partial_result_set flag. */
     thd->sp_runtime_ctx->end_partial_result_set= FALSE;
 
+#ifndef EMBEDDED_LIBRARY
+    extern char *ha_inst_group_name;
+    if (err_status && thd->get_stmt_da()->is_error() && 
+        ha_inst_group_name && 0 != strlen(ha_inst_group_name) &&
+        !thd->in_sub_stmt) 
+    {
+      uint mysql_errno = thd->get_stmt_da()->mysql_errno();
+      // notify HA set retry flag
+      mysql_audit_notify(thd, AUDIT_EVENT(MYSQL_AUDIT_GENERAL_LOG), 
+                         0, "SetDMLRetryFlag", 15);
+      if (mysql_errno && !thd->get_stmt_da()->is_set()) 
+      {
+        // 1. prepare-execution
+        if (thd->rewritten_query.length())
+          thd->rewritten_query.mem_free();
+        
+        // 2. reexecute
+        err_status = i->execute(thd, &ip);
+        
+        // 3. post-execution
+        thd->m_digest = parent_digest;
+        if (i->free_list)
+          cleanup_items(i->free_list);
+        if (thd->locked_tables_mode <= LTM_LOCK_TABLES)
+        {
+          thd->user_var_events.clear();
+          thd->user_var_events_alloc= NULL;//DEBUG
+        }
+        
+        thd->cleanup_after_query();
+        free_root(&execute_mem_root, MYF(0));
+        
+        if (!thd->is_fatal_error && !thd->killed_errno() &&
+          thd->sp_runtime_ctx->handle_sql_condition(thd, &ip, i))
+        {
+          err_status= FALSE;
+        }
+        thd->sp_runtime_ctx->end_partial_result_set= FALSE;
+      }
+      mysql_audit_notify(thd, AUDIT_EVENT(MYSQL_AUDIT_GENERAL_LOG), 
+                         0, "ResetDMLRetryFlag", 17);
+    }
+#endif
   } while (!err_status && !thd->killed && !thd->is_fatal_error);
 
 #if defined(ENABLED_PROFILING)
diff --git a/mysql-v5.7.25/sp_instr.cc b/mysql-v5.7.25/sp_instr.cc
index 3e19a87..be53581 100644
--- a/mysql-v5.7.25/sp_instr.cc
+++ b/mysql-v5.7.25/sp_instr.cc
@@ -37,7 +37,7 @@
 
 #include "trigger.h"                  // Trigger
 #include "table_trigger_dispatcher.h" // Table_trigger_dispatcher
-
+#include "sql_audit.h"
 
 class Cmp_splocal_locations :
   public std::binary_function<const Item_splocal*, const Item_splocal*, bool>
@@ -373,6 +373,26 @@ bool sp_lex_instr::reset_lex_and_exec_core(THD *thd,
 
   if (!error)
   {
+#ifndef EMBEDDED_LIBRARY
+    // notify HA check state for routines, 
+    // handle sql 'set m:= (select c1, c2,... cn from t1)' in function or procedure
+    {
+      extern char *ha_inst_group_name;
+      Sroutine_hash_entry *sroutine_to_open = thd->lex->sroutines_list.first;
+      enum enum_sql_command sql_cmd = thd->lex->sql_command;
+      if (sroutine_to_open != NULL && !thd->in_sub_stmt &&
+         (SQLCOM_END == sql_cmd || SQLCOM_SET_OPTION == sql_cmd) &&
+          ha_inst_group_name && 0 != strlen(ha_inst_group_name))
+      {
+        enum enum_sql_command saved_cmd = thd->lex->sql_command;
+        thd->lex->sql_command = SQLCOM_SET_OPTION;
+        mysql_audit_notify(thd, AUDIT_EVENT(MYSQL_AUDIT_GENERAL_LOG), 
+                           0, "PreCheckSQLObjects", 18);
+        thd->lex->sql_command = saved_cmd;
+      }
+    }
+#endif
+
     if (open_tables)
     {
       // todo: break this block out into a separate function.
@@ -445,6 +465,19 @@ bool sp_lex_instr::reset_lex_and_exec_core(THD *thd,
       error= exec_core(thd, nextp);
       DBUG_PRINT("info",("exec_core returned: %d", error));
     }
+
+#ifndef EMBEDDED_LIBRARY
+    // notify HA store lex for current statement
+    {
+      extern char *ha_inst_group_name;
+      if (error && thd->get_stmt_da()->is_error() && !thd->in_sub_stmt &&
+          ha_inst_group_name && 0 != strlen(ha_inst_group_name))
+      {
+        mysql_audit_notify(thd, AUDIT_EVENT(MYSQL_AUDIT_GENERAL_LOG), 
+                           0, "SaveInstrLex", 12);
+      }
+    }
+#endif
   }
 
   // Pop SP_instr_error_handler error handler.
diff --git a/mysql-v5.7.25/sql_base.cc b/mysql-v5.7.25/sql_base.cc
index 958246f..9765e53 100644
--- a/mysql-v5.7.25/sql_base.cc
+++ b/mysql-v5.7.25/sql_base.cc
@@ -5767,6 +5767,19 @@ restart:
          (thd->locked_tables_mode <= LTM_LOCK_TABLES &&
           *sroutine_to_open))
   {
+#ifndef EMBEDDED_LIBRARY
+    // check version before open table
+    // for statement including routines
+    extern char *ha_inst_group_name;
+    if (thd->lex->sroutines_list.first != NULL &&
+        SQLCOM_CALL != thd->lex->sql_command &&
+        !thd->in_sub_stmt &&
+        ha_inst_group_name && 0 != strlen(ha_inst_group_name))
+    {
+       mysql_audit_notify(thd, AUDIT_EVENT(MYSQL_AUDIT_GENERAL_LOG),
+                          0, "PreCheckSQLObjects", 18);
+    }
+#endif
     /*
       For every table in the list of tables to open, try to find or open
       a table.
diff --git a/mysql-v5.7.25/sql_class.cc b/mysql-v5.7.25/sql_class.cc
index 931bb26..9d9add1 100644
--- a/mysql-v5.7.25/sql_class.cc
+++ b/mysql-v5.7.25/sql_class.cc
@@ -2671,6 +2671,20 @@ bool sql_exchange::escaped_given(void)
 bool Query_result_send::send_result_set_metadata(List<Item> &list, uint flags)
 {
   bool res;
+
+  // do not send send_result_metadata once again for DML
+  extern char *ha_inst_group_name;
+  if (ha_inst_group_name && 0 != strlen(ha_inst_group_name))
+  {
+    extern thread_local_key_t ha_sql_stmt_info_key;
+    bool *is_ha_result_set_started = (bool*)my_get_thread_local(ha_sql_stmt_info_key);
+    if (is_ha_result_set_started && (*is_ha_result_set_started)) 
+    {
+      *is_ha_result_set_started = false;
+      return false;
+    }
+  }
+  
   if (!(res= thd->send_result_metadata(&list, flags)))
     is_result_set_started= 1;
   return res;
diff --git a/mysql-v5.7.25/sql_parse.cc b/mysql-v5.7.25/sql_parse.cc
index 52d319c..7b3cd36 100644
--- a/mysql-v5.7.25/sql_parse.cc
+++ b/mysql-v5.7.25/sql_parse.cc
@@ -1190,6 +1190,60 @@ void reset_statement_timer(THD *thd)
   thd->timer= NULL;
 }
 
+void reset_execution_ctx(THD *thd, const char *beginning_of_next_stmt, 
+                         ulong length, enum enum_server_command command) 
+{
+  /* Finalize server status flags after executing a statement. */
+  thd->update_server_status();
+  // thd->send_statement_status();
+  query_cache.end_of_result(thd);
+
+  log_slow_statement(thd);
+  /* PSI end */
+  MYSQL_END_STATEMENT(thd->m_statement_psi, thd->get_stmt_da());
+  thd->m_statement_psi= NULL;
+  thd->m_digest= NULL;
+
+  /* DTRACE end */
+  if (MYSQL_QUERY_DONE_ENABLED())
+  {
+    MYSQL_QUERY_DONE(thd->is_error());
+  }
+
+  /* SHOW PROFILE end */
+#if defined(ENABLED_PROFILING)
+  thd->profiling.finish_current_query();
+#endif
+
+/* SHOW PROFILE begin */
+#if defined(ENABLED_PROFILING)
+  thd->profiling.start_new_query("continuing");
+  thd->profiling.set_query_source(beginning_of_next_stmt, length);
+#endif
+
+  /* DTRACE begin */
+  MYSQL_QUERY_START(const_cast<char*>(beginning_of_next_stmt),
+                    thd->thread_id(),
+                    (char *) (thd->db().str ? thd->db().str : ""),
+                    (char *) thd->security_context()->priv_user().str,
+                    (char *) thd->security_context()->host_or_ip().str);
+
+  /* PSI begin */
+  thd->m_digest= & thd->m_digest_state;
+  thd->m_digest->reset(thd->m_token_array, max_digest_length);
+
+  thd->m_statement_psi= MYSQL_START_STATEMENT(&thd->m_statement_state,
+                                      com_statement_info[command].m_key,
+                                      thd->db().str, thd->db().length,
+                                      thd->charset(), NULL);
+  THD_STAGE_INFO(thd, stage_starting);
+
+  thd->set_query(beginning_of_next_stmt, length);
+  thd->set_query_id(next_query_id());
+  thd->status_var.questions++;
+  thd->set_time();
+}
+
 
 /**
   Perform one connection-level (COM_XXXX) command.
@@ -1482,6 +1536,37 @@ bool dispatch_command(THD *thd, const COM_DATA *com_data,
       break;
 
     mysql_parse(thd, &parser_state);
+#ifndef EMBEDDED_LIBRARY
+    {
+      extern char *ha_inst_group_name;
+      if (thd->get_stmt_da()->is_error() && ha_inst_group_name && 
+          0 != strlen(ha_inst_group_name) &&
+          0 == thd->lex->sroutines_list.elements) 
+      {
+        uint mysql_errno = thd->get_stmt_da()->mysql_errno();
+        // notify HA set retry flag
+        mysql_audit_notify(thd, AUDIT_EVENT(MYSQL_AUDIT_GENERAL_LOG), 
+                           0, "SetDMLRetryFlag", 15);
+        if (mysql_errno && !thd->get_stmt_da()->is_set()) 
+        {
+          const char *beginning_of_next_stmt= thd->query().str;
+          size_t length= static_cast<size_t>(packet_end - beginning_of_next_stmt);
+          reset_execution_ctx(thd, beginning_of_next_stmt, length, command);
+          parser_state.reset(beginning_of_next_stmt, length);
+          mysql_parse(thd, &parser_state);
+        }
+        // reset retry flag
+        mysql_audit_notify(thd, AUDIT_EVENT(MYSQL_AUDIT_GENERAL_LOG), 
+                           0, "ResetDMLRetryFlag", 17);
+      }
+      // clear checked objects cache
+      if (ha_inst_group_name && 0 != strlen(ha_inst_group_name)) 
+      {
+        mysql_audit_notify(thd, AUDIT_EVENT(MYSQL_AUDIT_GENERAL_LOG), 
+                           0, "ResetCheckedObjects", 19);
+      }
+    }
+#endif
 
     while (!thd->killed && (parser_state.m_lip.found_semicolon != NULL) &&
            ! thd->is_error())
@@ -1564,6 +1649,37 @@ bool dispatch_command(THD *thd, const COM_DATA *com_data,
       parser_state.reset(beginning_of_next_stmt, length);
       /* TODO: set thd->lex->sql_command to SQLCOM_END here */
       mysql_parse(thd, &parser_state);
+
+#ifndef EMBEDDED_LIBRARY
+      // sequoiadb-sql DML retry 
+      {
+        extern char *ha_inst_group_name;
+        if (thd->get_stmt_da()->is_error() && ha_inst_group_name && 
+            0 != strlen(ha_inst_group_name) &&
+            0 == thd->lex->sroutines_list.elements) 
+        {
+          uint mysql_errno = thd->get_stmt_da()->mysql_errno();
+          // notify HA set retry flag
+          mysql_audit_notify(thd, AUDIT_EVENT(MYSQL_AUDIT_GENERAL_LOG), 
+                             0, "SetDMLRetryFlag", 15);
+          if (mysql_errno && !thd->get_stmt_da()->is_set()) 
+          {
+            reset_execution_ctx(thd, beginning_of_next_stmt, length, command);
+            parser_state.reset(beginning_of_next_stmt, length);
+            mysql_parse(thd, &parser_state);
+          }
+          // reset retry flag
+          mysql_audit_notify(thd, AUDIT_EVENT(MYSQL_AUDIT_GENERAL_LOG), 
+                             0, "ResetDMLRetryFlag", 17);
+        }
+        // clear checked objects cache
+        if (ha_inst_group_name && 0 != strlen(ha_inst_group_name))
+        {
+          mysql_audit_notify(thd, AUDIT_EVENT(MYSQL_AUDIT_GENERAL_LOG), 
+                             0, "ResetCheckedObjects", 19);
+        }
+      }
+#endif
     }
 
     /* Need to set error to true for graceful shutdown */
@@ -4385,8 +4501,9 @@ end_with_restore_list:
         which doesn't any check routine privileges,
         so no routine privilege record  will insert into mysql.procs_priv.
       */
-
-      if (thd->slave_thread)
+      extern char *ha_inst_group_name;
+      bool ha_is_on = (ha_inst_group_name && 0 != strlen(ha_inst_group_name));
+      if (thd->slave_thread || ha_is_on)
       {
         LEX_CSTRING current_user;
         LEX_CSTRING current_host;
@@ -4428,7 +4545,7 @@ end_with_restore_list:
       */ 
       if (restore_backup_context)
       {
-        DBUG_ASSERT(thd->slave_thread == 1);
+        DBUG_ASSERT(thd->slave_thread == 1 || ha_is_on);
         thd->security_context()->restore_security_context(thd, backup);
       }
 #endif
@@ -4992,6 +5109,15 @@ finish:
       thd->killed= THD::NOT_KILLED;
     }
   }
+#ifndef EMBEDDED_LIBRARY
+  else {
+    mysql_audit_notify(thd,
+                      first_level ? MYSQL_AUDIT_QUERY_STATUS_END :
+                                    MYSQL_AUDIT_QUERY_NESTED_STATUS_END,
+                      first_level ? "MYSQL_AUDIT_QUERY_STATUS_END" :
+                                    "MYSQL_AUDIT_QUERY_NESTED_STATUS_END");
+  }
+#endif /* !EMBEDDED_LIBRARY */
 
   lex->unit->cleanup(true);
   /* Free tables */
@@ -5705,6 +5831,11 @@ bool add_field_to_list(THD *thd, LEX_STRING *field_name, enum_field_types type,
   Create_field *new_field;
   LEX  *lex= thd->lex;
   uint8 datetime_precision= decimals ? atoi(decimals) : 0;
+  user_var_entry *entry= NULL;
+  extern char *ha_inst_group_name;
+  bool default_is_set= (default_value != NULL);
+  const char *USE_STRICT_CREATE_MODE_VAR="SDB_USER_DEFINE_VAR_USE_STRICT_CREATE_MODE";
+  const char *USE_STRICT_CREATE_MODE_FLAG="SEQUOIADB_FLAG_USE_STRICT_CREATE_MODE";
   DBUG_ENTER("add_field_to_list");
 
   LEX_CSTRING field_name_cstr= {field_name->str, field_name->length};
@@ -5785,6 +5916,19 @@ bool add_field_to_list(THD *thd, LEX_STRING *field_name, enum_field_types type,
                       interval_list, cs, uint_geom_type, gcol_info))
     DBUG_RETURN(1);
 
+  entry= (user_var_entry*) my_hash_search(&thd->user_vars,
+                                          (uchar*) USE_STRICT_CREATE_MODE_VAR,
+                                          strlen(USE_STRICT_CREATE_MODE_VAR));
+  if (ha_inst_group_name && 0 != strlen(ha_inst_group_name) && !default_is_set &&
+      !(type_modifier & (NOT_NULL_FLAG | EXPLICIT_NULL_FLAG)) &&
+      !(type_modifier & AUTO_INCREMENT_FLAG) && entry &&
+      0 == strcmp(entry->ptr(), USE_STRICT_CREATE_MODE_FLAG)) {
+    if (thd->variables.explicit_defaults_for_timestamp ||
+        !is_timestamp_type(type)) {
+      new_field->flags|= NO_DEFAULT_VALUE_FLAG;
+    }
+  }
+
   lex->alter_info.create_list.push_back(new_field);
   lex->last_field=new_field;
   DBUG_RETURN(0);
